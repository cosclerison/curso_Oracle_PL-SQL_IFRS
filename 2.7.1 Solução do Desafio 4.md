## 2.7.1 Solução do Desafio 4

CREATE OR REPLACE PROCEDURE retorna_func_depto (p_id_departamento IN funcionario.id_departamento%type)
IS

CURSOR c_func_cargo IS
SELECT nome_funcionario, nome_cargo,salario
FROM funcironario f inner join cargo c
on f.id_cargo = c.id_cargo
where f.id_departamento = p_id_departamento;

BEGIN

FOR res IN c_func_cargo LOOP
DBMS_OUTPUT.PUT_LINE(res.nome_funcionario||' ' ||res.nome_cargo||' ' ||res.salario);
END LOOP;

END;

Explicando o código: O SELECT associado ao cursor faz um join entre as tabelas funcionario e cargo pois queremos retornar o nome, salario que estão na tabela funcionario e o cargo deste funcionário que está na tabela cargo. As tabelas são ligadas pelo id_cargo (ON f.id_cargo=c.id_cargo). Serão recuperados os dados dos funcionários que são do departamento cujo id é passado como parâmetro (WHERE f.id_departamento = p_id_departamento). 
O FOR LOOP faz o open,fetch e close do cursor de forma implícita, assim como a variável res tem declaração implícita (não precisa ser declara explicitamente na seção de declaração de variáveis) e só pode ser utilizada dentro do FOR LOOP. A variável res é um registro com os campos nome_funcionario, nome_cargo, salario que são os campos do select (SELECT nome_funcionario, nome_cargo,salario). Para imprimir o nome do funcionário é necessário colocar a variável res, um ponto e depois o nome do campo (res.nome_funcionario).


Versão 2: 
CREATE OR REPLACE PROCEDURE retorna_func_depto (p_id_departamento IN funcionario.id_departamento%type) IS

CURSOR c_func_cargo IS
SELECT nome_funcionario, nome_cargo,salario
FROM Funcionario f inner join cargo c
on f.id_cargo = c.id_cargo
WHERE f.id_departamento = p_id_departamento;

r_fc c_func_cargo%rowtype;

BEGIN

open c_func_cargo;
LOOP
FETCH c_func_cargo INTO r_fc;
IF c_func_cargo%NOTFOUND
THEN -- se encontrar o fim do cursor
EXIT;
END IF;
DBMS_OUTPUT.PUT_LINE(r_fc.nome_funcionario||' ' ||r_fc.nome_cargo||' ' ||r_fc.salario);
END LOOP;
CLOSE c_func_cargo;

﻿END;


Explicando o código: A diferença desta versão para a anterior é que os comandos OPEN, FETCH e CLOSE são explícitos pois não está sendo utilizado o comando FOR LOOP que realiza estas operações de forma implícita. Neste caso o comando FETCH está dentro de um laço de repetição pois deve ser executado uma vez para cada uma das linhas do resultado. A variável r_fc é declarada antes do BEGIN e é um registro com o mesmo tipo da linha (rowtype) do cursor c_func_cargo, ou seja, um registro com os campos do select (nome_funcionario, nome_cargo,salario). Depois de utilizado o cursor deve ser fechado para que a área de memória que contém o resultado da consulta seja liberada. O CLOSE c_func_cargo é executado depois do faço de repetição, depois do END LOOP.